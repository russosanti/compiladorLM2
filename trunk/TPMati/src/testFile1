globales
	const M : natural = 7n, R : entero = 90;
	var N, S : entero;
	var Z[12n] : natural;
fin-globales;

procedimiento PROC1();
var A : entero;
var B : natural;
comenzar
  B := M;
  mientras B < 0 hacer
    si par(B) entonces
      A := A + 1;
    sino
	    N := 70;
    fin-si;
    mostrarLN 'Visualizacion', B, ' ', A;
    B := B - 1;
  fin-mientras;
fin-proc;

procedimiento PROC2(ref R : entero);
const T : natural = 67n;
var W11 : entero;
var W12, Q, PP :natural;
var Y: entero;
comenzar
  S := (S ++ M) ** 2n;
  Q := 1n;
  leer W11;  {lectura de teclado}
  W12 := ANATURAL(W11 * 2 + S);
  mientras (W12 + 2) < PP + S hacer
    W12 := W12 * 2;
  fin-mientras;
  mientras W12 + M < Y / 2 hacer

   	Q := Q * 2;
    W12 := W12 / 2;
    si W12 < R entonces
      PP := PP + W12;
      Q := Q + 1;
    fin-si;
  fin-mientras;
  Z[1n] := Q;
fin-proc;

funcion FUN1(T: entero, val N2 : entero) : entero;
comenzar
  si T < 0 entonces
    N := 45;
  sino
    N := 70;
  fin-si;
fin-func N * 2;

procedimiento PRINCIPAL();
var X: entero;
comenzar
  PROC1();
  S := M + 1;
  PROC2(S);
  X := FUN1(5, 8);
  Z[5n] := X;
  mostrar Z[ANATURAL(S) ++ 1n];
fin-proc;
  